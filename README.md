Как его зовут:
    qbot
Зачем он:
    - Контроль и управление удаленными/изолированными системами и устройствами без необходимости использовать "белые" IP-адреса и фронтенды в Интернет
Что ему нужно:
    - Доступ к одному из общедоступных каналов: Telegram, ВКонтакте, Email, SMS, Telnet в локальной сети (список может быть пополнен)
    - Операционную систему Linux c systemd. Тестировался на Ubuntu 18.04, Raspbian. Должен неплохо жить и на других дистрибутивах
    - Python 3. С уверенностью можно сказать, что он работает на 3.5 и 3.6
    - Несколько дополнительных пакетов Python 
Что он может:
    - Выполнять любые определенные Вами команды и возвращает результат их выполнения. 
    - Посылать оповещения о значимых для Вас событиях.
    - Команды, события и оповещения могут быть заданы как в коде новых модулей, так и в YAML-конфигах
    - Принимать и присылать файлы
    - Принимать и ставить присланные Вами по рабочим каналам обновления, не требуя Вашего присутствия
    - Выдавать определяемый Вами help
Особенности характера:
    - "Зациклен" на отказоустойчивости. Иногда в ущерб скорости и эффективности
    - Дает Вам полную свободу в редактировании своего поведения (определение команд, алертов)
    - При этом дает неплохие инструменты для реализации своих идей: модульная архитектура дает возможность на основе имеющихся создавать новые модули-          коннекторы и модули-менеджеры, реализовывая новые каналы связи и новые модули управления всем, с чем способен работать Python 3.5+
    - Единое поле команд и событий для всех каналов доступа
    - Безопасность (пока) не его конёк. Реализовано ограничение доступа по белому списку контактов, также можно пользоваться стандартными методами соответствующих мессенджеров. В любом случае, большая свобода предполагает большую ответственность и Вы сами имеете возможность создавать безопасные модули
    - Двойной механизм отката обновлений: при отсутствии подтверждения со стороны хозяина и при неудачном старте
    - Запуск в тестовой конфигурации при наличии в корневом каталоге файла isTest. Для тестирования оченно полезно
    - Пишет все в лог, находящийся home directory

Структура каталогов:
    ./ (work directory) - скрипты запуска/остановки службы systemd, log-файл, флаги апдейта и тестовой конфигурации
    backup - хранение бэкапов рабочих файлов (в основном, run), созданных при апдейтах или вручную
    download - Загрузки
    lib - библиотеки, необходимые для работы модулей управления. Ядру и коннекторам не нужен
    run - рабочие файлы (ядро, модули, базы данных модулей и т.д)
    run/conf - конфигурационные файлы
    tmp - pid-файл, прочие временные файлы (пока их нет, прочих)
    update - сюда выкладывать апдейты (затираются после применения)
    upload - для симметричности с download. Не используется ботом (пока?)
Содержимое ./:
    - start_qbot.sh - старт-скрипт для systemd
    - stop_qbot.sh - стоп-скрипт для systemd
    - update_flad - флаг режима апдейта (цифра в файле показывает количество запусков qbot в этом режиме)
    - isTest - флаг тестовой конфигурации (содержимое неважно)
Содержимое run/:
    - qbot.py - модуль ядра
    - qmessenger.py - базовый модуль для коннекторов
    - qvkmessenger.py - коннектор ВКонтакте
    - qsmsmessenger.py - коннектор SMS
    - qtelegrammessenger.py - коннектор Telegram (иногда требует соединения через tor)
    - qconsolemessenger.py - консольный коннектор (из локальной сети, порт 49049, если Вы не настроите другой)
    - qemailmessenger.py - Email коннектор
    - qbasemanager.py - базовый модуль для модулей управления
    - qrpimanager.py - реализация модуля управления для системы из 4 реле, 3 радиорозеток 433Мгц и двух датчиков DS18B20 на базе Raspberry Pi 3
    - conf/qbot.yaml - конфиг ядра
    - conf/commands.yaml - описание команд
    - conf/qrpimanager.yaml - конфиг для qrpimanager.py с командами и алертами
Архитектура:
    - Открытая модульная. Модули 2 видов: коннекторы и модули управления
    - Коннекторы реализованы в виде отдельных потоков threading.Thread с единой очередью команд. Интерфейс классов задан модулем qmessenger
    - Модули управления - в виде отдельных процессов multiprocessing, общение с главным модулем производится при помощи двух пар Pipe-объектов, один - для передачи команд и ответов на них, другой - для передачи событий сгенерированных самим модулем (алертов)
    - Коннекторы и модули - динамически подгружаемые, их состав определяет файлом конфигурации
    - Задача центрального модуля - принять команду от коннектора, проверить валидность отправителя, выполнить ее и отправить результат тем же транспортом. Также принять алерт от модуля(ей) управления, и отправить его прописанным контактам через дефолтные коннекторы
    
